<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大爱の小窝</title>
  
  <subtitle>落魄谷中寒风吹,春秋蝉鸣少年归</subtitle>
  <link href="https://qiride.github.io/atom.xml" rel="self"/>
  
  <link href="https://qiride.github.io/"/>
  <updated>2025-02-14T07:29:50.581Z</updated>
  <id>https://qiride.github.io/</id>
  
  <author>
    <name>大爱黎尊</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于前端的知识二</title>
    <link href="https://qiride.github.io/post/d2407e80.html"/>
    <id>https://qiride.github.io/post/d2407e80.html</id>
    <published>2025-02-14T05:42:36.000Z</published>
    <updated>2025-02-14T07:29:50.581Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="关于前端的知识二"><a href="#关于前端的知识二" class="headerlink" title="关于前端的知识二"></a>关于前端的知识二</h1><h2 id="1-编程语言"><a href="#1-编程语言" class="headerlink" title="1. 编程语言"></a>1. 编程语言</h2><h3 id="1-1-JavaScript和ECMAScript规范"><a href="#1-1-JavaScript和ECMAScript规范" class="headerlink" title="1.1 JavaScript和ECMAScript规范"></a>1.1 JavaScript和ECMAScript规范</h3><p>ECMAScript 6或者说是ECMAScript 2015,他是一套文档,规范了脚本语言的设计包括语法,数据类型,内置对象等等</p><p>JavaScript则是遵循这套规范的编程语言之一,ES规范确保了无论在何处使用JS,它的写法和行为都是一致的,ES每年都在引入新特性从ES2015的let/const,箭头函数到ES2024的Object.groupBy等等,借助现代工具链的转义和polyfills的等效实现,我们可以在不支持这种新特性的环境下使用它们</p><h3 id="1-2-TypeScript"><a href="#1-2-TypeScript" class="headerlink" title="1.2 TypeScript"></a>1.2 TypeScript</h3><p>TypeScript是JavaScript的超集,它在JavaScript的基础上添加了静态类型检查,这使得代码更加健壮,易于维护,同时也可以在编译阶段发现一些错误,使得许多错误常见错误在编译阶段就会暴露出来</p><h3 id="1-3-Rust"><a href="#1-3-Rust" class="headerlink" title="1.3 Rust"></a>1.3 Rust</h3><p>近些年Rust在前端发展十分迅猛,正在逐步占领前端工具链,举个栗子,对标Babel的SWC,对标Webpack的Espace,Farm,Next.js的Turbopack都是基于Rust语言编写的,出现这种情况的最根本原因是前端项目的体谅越来越大,构建性能已经成为瓶颈,传统的打包优化方案已经无法进一步提高性能,所以需要借助性能更强的编程语言</p><h3 id="1-4-WebAssembly"><a href="#1-4-WebAssembly" class="headerlink" title="1.4 WebAssembly"></a>1.4 WebAssembly</h3><p>WebAssembly简称Wasm最早用于浏览器计算密集型任务,而到了现在它已然成为一套完整的应用运行生态,通常是通过系统语言C/C++/Go和Rust的编译目标之一,Wasm Runtime的出现使得其能够以在非浏览器的环境下运行,WASI API又为Wasm提供了访问系统的能力,比如文件系统和网络等,Wasm除了满足重度计算需求外,还应用于跨平台开发,安全沙箱,容器和虚拟化技术</p><h3 id="1-5-领域特定语言"><a href="#1-5-领域特定语言" class="headerlink" title="1.5 领域特定语言"></a>1.5 领域特定语言</h3><p>领域特定语言(DSL),它通常是在某个现有语言基础上增加一定约束和拓展,应用于某个特定场景,如微信小程序中的WXML,和在React中使用的JSX,Vue中的template,这些都统称为领域特定语言,领域特定语言并不是通用型语言,但是相对于通用性语言来说,它的语法更简单,开发效率更高,专业对口业务,可维护性强</p><h3 id="1-6-JavaScript引擎和运行时"><a href="#1-6-JavaScript引擎和运行时" class="headerlink" title="1.6 JavaScript引擎和运行时"></a>1.6 JavaScript引擎和运行时</h3><p>写的代码要运行当然离不开,JS引擎和JS运行时,JS引擎负责解释和执行JS代码,而JS运行时不仅自带了一个JS引擎,还提供了一些内置对象和API,如DOM,Web API,Node.js API等,项目容易出现浏览器兼容问题多半都是使用的JS运行时不同导致的,如Chrome浏览器提供了基于V8引擎的运行时,而Safari浏览器提供了基于JavaScriptCore引擎的运行时,虽然都提供了Web API,但在实现上又这细微差异</p><p>Node.js是最常用的JS运行时,但在企业级的大型项目Node.js中,仅仅用它还是不够的,大型Node.js的应用还会考虑性能监控,安全提醒,故障排除,性能优化等问题,如阿里云前端基建团队的Node.js性能平台(alinode)就在Node.js的基础上添加了这些功能,提供了一整套方案</p><h2 id="2-简单又复杂的工具链"><a href="#2-简单又复杂的工具链" class="headerlink" title="2. 简单又复杂的工具链"></a>2. 简单又复杂的工具链</h2><h3 id="2-1-什么是工具链"><a href="#2-1-什么是工具链" class="headerlink" title="2.1 什么是工具链"></a>2.1 什么是工具链</h3><p>工具链通常是指一组用于软件开发的工具和技术,帮助开发者管理好从源代码到最终软件的整个开发过程,对于前端来讲这些工具通常包括集成开发环境(IDE),包管理工具,构建工具,调试工具,持续集成和部署(CI/CD)工具等,大多以VSCode作为IDE,这不是因为它具有良好的开发体验,还得益于强大了插件生态,让一些比较新的语言或开发工具也能方便的集成进来,前端开发中的很多人物都可以在VSCode中的一站式完成,如版本控制Git,管理NPM包和脚本,调试Node.js程序等,另外还有许多于本地VSCode相似的云IDE,如腾讯的Cloud studio,阿里云的Cloud IDE等</p><h3 id="2-2-包管理工具"><a href="#2-2-包管理工具" class="headerlink" title="2.2 包管理工具"></a>2.2 包管理工具</h3><p>包管理是现代软件开发绕不开的话题,自前端开启模块化开发后,以npm为代表的包管理器也应运而生,包管理的核心是代码组织与复用,这也是开发大型项目所必须的要求,现代前端的包管理工具又几个代表npm,yarn,pnpm,他们各有特点</p><ul><li><strong>npm</strong>: 广泛采用,兼容性强,速度较慢</li><li><strong>yarn</strong>: 并行安装+缓存,资源消耗较大</li><li><strong>pnpm</strong>: 共享依赖模型,兼容性问题较多</li></ul><p>如上特点可以看到每一代包管理器都会解决上一代的问题,又快又省是包管理器的核心演进方向,前端有一个数量很大的软件生态,大到一个工具小到一个函数都可以坐成一个包,许多包有直接或间接依赖另一些包,在加上版本不同,因此包管理是一件相当复杂的事,虽然开源包管理工具已经很好的解决了安装速度和资源消耗的问题,但是企业级的包管理还可以做更多事情,比较典型的场景是应对供应链的污染,前端项目的直接供应商是npm仓库,一个带有bug的包发布后会导致本地或持续集成环境产生问题,因此企业级包管理器会在开源包管理器的基础上,增加对bug包的黑名单控制,例如cnpm的bug-versions就是维护了一套黑名单</p><h3 id="2-3-构建工具"><a href="#2-3-构建工具" class="headerlink" title="2.3 构建工具"></a>2.3 构建工具</h3><p>前端构建工具的出现比较晚,首先是基于Task Runner 的 Grunt(2010) 和 Gulp(2013)以及模块化打包工具Browserify(2011),Webpack(2012)和Rollup(2015)然后是现代的Parcel(2017),vite(2020),Turbopack(2022)和Rspack(2023)等,现代前端构建工具通常包含代码转译器,优化器,打包器,开发服务器,和插件系统</p><ul><li><strong>转译器</strong>: 负责将源代码转换为目标平台可以直接运行的代码,同时让一些比较新的语言特性可以兼容旧的环境,如JSX到JS的转换</li><li><strong>优化器</strong>: 优化器是将转译完成的代码进一步优化,如压缩,混淆和分割,以提升传输效率和安全性</li><li><strong>打包器</strong>: 打包器将转译好的代码合并到一起通常内置转译器和优化器从源代码到最终产物一站式完成</li><li><strong>开发服务器</strong>: 开发服务器提供一个本地的http服务器,通过HMR,传输原生ES模块,接口代理等功能来提高开发体验</li><li><strong>插件系统</strong>: 插件系统是功能拓展的主要方式,可以灵活改变整个构建项目的行为,来实现定制化需求</li></ul><p>近些年前端构建工具的大趋势是机制整合以及使用Rust重写核心模块</p><ul><li><strong>极致整合</strong>: 为了减少学习负担</li><li><strong>Rust重写核心模块</strong>: 为了显著提升构建和打包效率</li></ul><h3 id="2-4-调试工具"><a href="#2-4-调试工具" class="headerlink" title="2.4 调试工具"></a>2.4 调试工具</h3><p>现代前端针对不同的场景会用到不同的调试工具,浏览器开发者工具用于普通的HTML界面的UI,网络,性能调试,比如Chrome DevTools,小程序开发者工具用于小程序模拟和真机调试,接口调试工具Postman,Charles等,框架自带的调试工具,如React Developer,Vue Devtools等,它们可以展示更为直观的虚拟DOM结构和组件状态</p><h3 id="2-5-CI-CD工具"><a href="#2-5-CI-CD工具" class="headerlink" title="2.5 CI/CD工具"></a>2.5 CI/CD工具</h3><p>一个健壮和可靠的软件研发流程离不开持续集成(CI)和持续部署(CD),CI/CD在现代前端也是必不可少的,它并不复杂,现在我们可以借助Github Action,Travis CI,Jenkins等工具或平台来轻松完成这些事情</p><h3 id="2-6-为什么简单的的同时复杂"><a href="#2-6-为什么简单的的同时复杂" class="headerlink" title="2.6 为什么简单的的同时复杂"></a>2.6 为什么简单的的同时复杂</h3><ul><li><p><strong>简单</strong>: 因为它对开发这屏蔽了许多内部细节,比如基本都内置了诸如HMO,转译工具,CSS预处理等工具,配合脚手架用起来简单</p></li><li><p><strong>复杂</strong>: 因为它们有的选择兼容Rollup生态(vite),有的选择兼容Webpack(Rspack)生态,有的则另辟蹊径(Turbopack),这导致它们的底层架构大不相同,如开发者需要深度定制,则会面临许多取舍和困难</p></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;h1 id=&quot;关于前端的知识二&quot;&gt;&lt;a href=&quot;#关于前端的知识二&quot; class=&quot;headerlink&quot; title=&quot;关于前端的知识二&quot;&gt;&lt;/a&gt;关于前端的知识二&lt;/h1&gt;&lt;h2 id=&quot;1-编程语言&quot;&gt;&lt;a href=&quot;#1-编程语言&quot; cl</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://qiride.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于前端的知识一</title>
    <link href="https://qiride.github.io/post/e9c05029.html"/>
    <id>https://qiride.github.io/post/e9c05029.html</id>
    <published>2025-02-13T06:45:28.790Z</published>
    <updated>2025-02-13T08:07:59.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="关于前端的知识一"><a href="#关于前端的知识一" class="headerlink" title="关于前端的知识一"></a>关于前端的知识一</h1><p>本文章主要讲解什么是前端以及了解什么是DNS,http</p><h2 id="1-什么是前端"><a href="#1-什么是前端" class="headerlink" title="1.什么是前端"></a>1.什么是前端</h2><h3 id="1-1-前端的历史"><a href="#1-1-前端的历史" class="headerlink" title="1.1 前端的历史"></a>1.1 前端的历史</h3><p>前端的历史可以追溯到1990年代，当时的互联网还处于早期阶段，网页的设计和开发主要依赖于静态的HTML页面。随着互联网的发展，前端技术也逐渐得到了广泛的应用。</p><h3 id="1-2-现代前端的工作"><a href="#1-2-现代前端的工作" class="headerlink" title="1.2 现代前端的工作"></a>1.2 现代前端的工作</h3><p>现代前端除了解决人机交互这个主要问题外,还拓展出了很多用户体验和工程问题</p><p>用户体验:</p><ul><li><strong>性能优化</strong>: 更加有效的提升用户界面的加载效率</li><li><strong>无障碍化</strong>: 如何保证在不同设备上的兼容性 </li><li><strong>交互设计</strong>: 如何改善在移动设备的交互方式</li><li><strong>个性化需求</strong>: 如何满足个性化需求</li></ul><p>工程配置:</p><ul><li><strong>研发质量</strong>: 如何大幅度提高开发效率和质量</li><li><strong>安全措施</strong>: 如何保证前端安全</li><li><strong>监控和数据</strong>: 如何利用实时监控了解应用健康度</li><li><strong>部署运维</strong>: 如何利用云基础平台进行部署和运维</li></ul><h3 id="1-3-现代前端与过去的区别"><a href="#1-3-现代前端与过去的区别" class="headerlink" title="1.3 现代前端与过去的区别"></a>1.3 现代前端与过去的区别</h3><p>过去的前端主要依赖于HTML、CSS和JavaScript,等技术完成界面开发，对接后端接口即可</p><p>现代前端的能力边界已经拓展了许多，还需要照顾到体验,效能,工程化,数据运营,部署运维,终端安全,多端适配等,这些都是为了更好的服务与人机交互</p><p>举个栗子!现代前端的界面渲染方式已经从客户端渲染(CSR)过渡到部分服务端渲染(SSR),而流式渲染(Streaming)我认为是未来的趋势,流式渲染与服务器渲染的最大区别简单来说就是流式渲染的速度比服务器渲染快</p><p>现代前端很多时候都不全是在做前端的事,前端与服务端的界限已经越来越模糊,当然前端借助服务端所做的一切都是为了服务于用户的体验</p><h2 id="2-什么是DNS"><a href="#2-什么是DNS" class="headerlink" title="2.什么是DNS"></a>2.什么是DNS</h2><p>DNS(Domain Name System)是互联网的基础,它将域名和IP地址相互映射,使得用户可以通过域名访问网站,而不是IP地址,现代DNS服务器除了基本的域名解析功能外，还会提供安全插件(DNSSEC),DNS分析,边缘网络加速解析,DDos防护等功能,这些功能都是为了更快,更安全的为用户提供服务</p><h3 id="2-1-DNS的工作原理"><a href="#2-1-DNS的工作原理" class="headerlink" title="2.1 DNS的工作原理"></a>2.1 DNS的工作原理</h3><p>当用户在浏览器中输入一个域名时,浏览器会首先检查本地的DNS缓存,如果缓存中有对应的IP地址,则直接返回,否则会向本地DNS服务器,最后得到的是IP地址,当然这些服务器大概率不是最终的应用服务器，而是具有反向代理的负载均衡(LB)服务器或WEB应用防火墙(WAW)等,真正的应用服务器IP地址不会暴露在公网环境</p><h3 id="2-2-内容分发系统-CDN-与DNS的关系"><a href="#2-2-内容分发系统-CDN-与DNS的关系" class="headerlink" title="2.2 内容分发系统(CDN)与DNS的关系"></a>2.2 内容分发系统(CDN)与DNS的关系</h3><p>在不同地区的用户在访问前端静态资源时会从不同的cdn节点下载数据,这归功于DNS系统的CNAME记录,DNS服务器会根据用户所在地区的不同,将用户引导到最近的cdn节点也就是CNAME域名,从而提高用户的访问速度</p><p>举个栗子,假如我们的图片资源托管在img.alicdn.com上,通过nslookup工具以此查询当前域名的CNAME和A记录,最终我们会得到CDN服务器的IP地址,实际的地理位置会是在离你最近的CDN节点上</p><p>如栗子所说DNS解析不是一轮完成,会进行多次查询,所以会非常慢,所以不管是DNS云服务器还是互联网上的基础设施,都会想尽办法加速DNS解析的速度如使用高性能的DNS服务器,DNS缓存，增加DNS记录的缓存时间(TTL)等方式,作为前端我们可是使用浏览器提供的DNS预取功能<link rel='dns-prefetch' href='//cdn.example.com'/>来指定需要提前解析的域名,也可以根据DNS的缓存原理通过本地调试的方式设置本地host来解决cookies的跨域问题</p><h2 id="3-什么是HTTP协议"><a href="#3-什么是HTTP协议" class="headerlink" title="3.什么是HTTP协议"></a>3.什么是HTTP协议</h2><p>HTTP协议是连接世界的桥梁,是人们打开互联网的y钥匙,它对于前端的重要性是毫无疑问的,虽然HTTP叫传输协议,但它实际上是工作在TCP/IP协议栈的应用层,底层的数据传输由TCP或UDP负责</p><h3 id="3-1-HTTP的版本"><a href="#3-1-HTTP的版本" class="headerlink" title="3.1 HTTP的版本"></a>3.1 HTTP的版本</h3><ul><li><strong>HTTP/1.1</strong>: 目前还是广泛的版本,它支持持久连接,支持管线化,支持请求和响应的压缩,支持缓存等</li><li><strong>HTTP/2</strong>:引入了多路复用,二进制帧层,头部压缩等特性,提高了不少传输性能</li><li><strong>HTTP/3</strong>:基于QUIC协议使用UDP作为传输层,进一步降低了链接延迟和提高了不少传输性能</li></ul><p>HTTPS是HTTP的安全版本,它使用了SSL/TLS协议来加密数据传输,确保数据的安全性,HTTPS的加密方式有对称加密和非对称加密两种,对称加密是指加密和解密使用同一个密钥,而非对称加密是指加密和解密使用不同的密钥,HTTPS的加密方式是先使用非对称加密来交换密钥,然后使用对称加密来加密数据,这样可以保证数据的安全性(HTTP/3 强制要求需要)</p><h3 id="3-2-HTTP的工作原理"><a href="#3-2-HTTP的工作原理" class="headerlink" title="3.2 HTTP的工作原理"></a>3.2 HTTP的工作原理</h3><p>HTTP协议是基于请求和响应的,客户端向服务器发送请求,服务器处理请求并返回响应,HTTP协议是无状态的,即每次请求都是独立的,服务器不会记录客户端的状态,HTTP协议是基于TCP/IP协议栈的应用层协议,底层的数据传输由TCP或UDP负责</p><p>举个栗子,我的图片放在服务器上,我如果要得到这张图片我可以通过向服务器发送我想要图片的这个请求，服务器收到后会给我反馈也就是响应常见的响应是JSON格式的其中注意code返回的值2开头标识成功,4开头标识失败,5开头标识服务器错误,常见的响应状态码有200,301,302,404,500等</p><h3 id="3-3-异步请求"><a href="#3-3-异步请求" class="headerlink" title="3.3 异步请求"></a>3.3 异步请求</h3><p>前端和服务端的异步请求求通常也是通过HTTP协议完成,最早是通过XMLHttpRequest(XHR)完成的,但是随着ES6的出现,前端也可以使用Fetch API来完成异步请求,异步请求的好处是可以提高用户体验,减少页面的加载时间,但是也会带来一些问题,如请求的顺序问题,请求的并发数问题,请求的缓存问题等,这些问题都需要我们在开发中进行考虑</p><h3 id="3-4-调试工具"><a href="#3-4-调试工具" class="headerlink" title="3.4 调试工具"></a>3.4 调试工具</h3><p>浏览器开发者工具,在Chrome浏览器中可以使用F12打开开发者工具,在开发者工具中通过Network选项卡查看网络请求的请求和响应信息,如想快速看看可以通过cURL等命令行工具完成,在对api测试时可以使用Postman等自动化工具来批量完成,如需要调试移动设备的HTTPS则需要安装信任证书以及通过网络代理工具来实现,如对于远程以及生产环境则需要使用抓包工具和分析服务器日志来完成</p><h3 id="3-5-HTTP在大型客户端应用中的变体"><a href="#3-5-HTTP在大型客户端应用中的变体" class="headerlink" title="3.5 HTTP在大型客户端应用中的变体"></a>3.5 HTTP在大型客户端应用中的变体</h3><p>为了更高效和安全的传输数据,同时兼容HTTP协议,会有一些变化,不是所有的客户端环境都支持先进的HTTP/2或HTTP/3原始HTTP协议在更复杂的高并发场景下会不够高效或稳定,大型技术基建通常会设计一层无线网关(Gateway)并对HTTP协议进行定制添加登录验证,请求跟踪,监控,限流等功能,而前端代码通过远程过程调用(RPC)的方式,而不是使用原始的HTTP,定制化的HTTP协议可以带来更加强大的功能</p></blockquote><!-- 举个栗子,bilibili前端发起一个grpc请求刀gateway网关,同时发送多个自定义请求头 -->]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;h1 id=&quot;关于前端的知识一&quot;&gt;&lt;a href=&quot;#关于前端的知识一&quot; class=&quot;headerlink&quot; title=&quot;关于前端的知识一&quot;&gt;&lt;/a&gt;关于前端的知识一&lt;/h1&gt;&lt;p&gt;本文章主要讲解什么是前端以及了解什么是DNS,http&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://qiride.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于使用JMeter进行并发量测试</title>
    <link href="https://qiride.github.io/post/a1286495.html"/>
    <id>https://qiride.github.io/post/a1286495.html</id>
    <published>2025-02-12T05:06:46.000Z</published>
    <updated>2025-02-13T08:08:04.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于使用JMeter进行并发量测试"><a href="#关于使用JMeter进行并发量测试" class="headerlink" title="关于使用JMeter进行并发量测试"></a>关于使用JMeter进行并发量测试</h1><blockquote><p>在当今的互联网时代，网站的并发量测试是确保网站稳定性和性能的重要手段之一。对于使用Vue.js构建的前端网站，使用JMeter进行并发量测试可以帮助我们了解网站在高并发情况下的表现。本文将介绍如何使用JMeter对Vue网站进行并发量测试。</p><h2 id="1-JMeter什么东东"><a href="#1-JMeter什么东东" class="headerlink" title="1. JMeter什么东东"></a>1. JMeter什么东东</h2><p>Apache JMeter是一个开源的性能测试工具，主要用于对Web应用程序进行负载测试和性能测试。它支持多种协议，如HTTP、HTTPS、FTP、SOAP、REST等，并且可以通过插件扩展功能。</p><h2 id="2-前提条件"><a href="#2-前提条件" class="headerlink" title="2. 前提条件"></a>2. 前提条件</h2><p>在开始测试之前，我们需要准备以下内容：</p><ul><li><strong>JMeter安装</strong>：确保已经安装并配置好JMeter。可以从<a href="https://jmeter.apache.org/download_jmeter.cgi">Apache JMeter官网</a>下载最新版本。</li><li><strong>测试计划</strong>：明确测试的目标，例如测试网站的登录接口、数据加载接口等。<h2 id="3-创建JMeter测试计划"><a href="#3-创建JMeter测试计划" class="headerlink" title="3. 创建JMeter测试计划"></a>3. 创建JMeter测试计划</h2></li></ul><h3 id="3-1-添加线程组"><a href="#3-1-添加线程组" class="headerlink" title="3.1 添加线程组"></a>3.1 添加线程组</h3><ol><li>打开JMeter，右键点击“Test Plan”，选择“Add” -&gt; “Threads (Users)” -&gt; “Thread Group”。</li><li>在“Thread Group”中设置线程数（即并发用户数）、Ramp-Up时间（用户启动时间）和循环次数。</li></ol><h3 id="3-2-添加HTTP请求"><a href="#3-2-添加HTTP请求" class="headerlink" title="3.2 添加HTTP请求"></a>3.2 添加HTTP请求</h3><ol><li>右键点击“Thread Group”，选择“Add” -&gt; “Sampler” -&gt; “HTTP Request”。</li><li>在“HTTP Request”中设置服务器名称或IP（即你的Vue网站地址）、端口号、请求方法（GET/POST等）以及路径。</li><li>如果需要传递参数，可以在“Parameters”或“Body Data”中设置。</li></ol><h3 id="3-3-添加监听器"><a href="#3-3-添加监听器" class="headerlink" title="3.3 添加监听器"></a>3.3 添加监听器</h3><ol><li>右键点击“Thread Group”，选择“Add” -&gt; “Listener” -&gt; “View Results Tree”。</li><li>添加其他监听器，如“Summary Report”或“Graph Results”，以便查看测试结果。</li></ol><h3 id="4-运行测试"><a href="#4-运行测试" class="headerlink" title="4. 运行测试"></a>4. 运行测试</h3><ol><li>点击JMeter工具栏上的“Start”按钮，开始运行测试。</li><li>在测试过程中，可以通过监听器实时查看测试结果。</li></ol><h3 id="5-分析测试结果"><a href="#5-分析测试结果" class="headerlink" title="5. 分析测试结果"></a>5. 分析测试结果</h3><p>测试完成后，可以通过以下方式分析结果：</p><ul><li><strong>View Results Tree</strong>：查看每个请求的详细结果，包括请求和响应数据。</li><li><strong>Summary Report</strong>：查看测试的总体结果，包括平均响应时间、吞吐量、错误率等。</li><li><strong>Graph Results</strong>：以图表形式展示响应时间、吞吐量等指标的变化趋势。</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于使用JMeter进行并发量测试&quot;&gt;&lt;a href=&quot;#关于使用JMeter进行并发量测试&quot; class=&quot;headerlink&quot; title=&quot;关于使用JMeter进行并发量测试&quot;&gt;&lt;/a&gt;关于使用JMeter进行并发量测试&lt;/h1&gt;&lt;blockquote&gt;
</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="https://qiride.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>建站啦！！！</title>
    <link href="https://qiride.github.io/post/21ba1eea.html"/>
    <id>https://qiride.github.io/post/21ba1eea.html</id>
    <published>2025-02-11T05:04:23.000Z</published>
    <updated>2025-02-13T06:46:02.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="建站啦！！！"><a href="#建站啦！！！" class="headerlink" title="建站啦！！！"></a>建站啦！！！</h1><blockquote><p>2025-02-11 13:04:23<br>今天是我建站的第一天，我要做一个博客，记录我的学习过程，也记录我的生活。</p><h2 id="我要做什么？"><a href="#我要做什么？" class="headerlink" title="我要做什么？"></a>我要做什么？</h2><ul><li>记录我的学习过程</li><li>记录我的生活</li><li>记录我的心情</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;建站啦！！！&quot;&gt;&lt;a href=&quot;#建站啦！！！&quot; class=&quot;headerlink&quot; title=&quot;建站啦！！！&quot;&gt;&lt;/a&gt;建站啦！！！&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;2025-02-11 13:04:23&lt;br&gt;今天是我建站的第一天，我要做一个博客</summary>
      
    
    
    
    
  </entry>
  
</feed>
