<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大爱の小窝</title>
  
  <subtitle>落魄谷中寒风吹,春秋蝉鸣少年归</subtitle>
  <link href="https://qiride.github.io/atom.xml" rel="self"/>
  
  <link href="https://qiride.github.io/"/>
  <updated>2025-02-13T08:04:02.290Z</updated>
  <id>https://qiride.github.io/</id>
  
  <author>
    <name>大爱黎尊</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于前端的知识一</title>
    <link href="https://qiride.github.io/post/e9c05029.html"/>
    <id>https://qiride.github.io/post/e9c05029.html</id>
    <published>2025-02-13T06:45:28.790Z</published>
    <updated>2025-02-13T08:04:02.290Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="关于前端的知识一"><a href="#关于前端的知识一" class="headerlink" title="关于前端的知识一"></a>关于前端的知识一</h1><p>本文章主要讲解什么是前端以及了解什么是DNS,http</p><h2 id="1-什么是前端"><a href="#1-什么是前端" class="headerlink" title="1.什么是前端"></a>1.什么是前端</h2><h3 id="1-1-前端的历史"><a href="#1-1-前端的历史" class="headerlink" title="1.1 前端的历史"></a>1.1 前端的历史</h3><p>前端的历史可以追溯到1990年代，当时的互联网还处于早期阶段，网页的设计和开发主要依赖于静态的HTML页面。随着互联网的发展，前端技术也逐渐得到了广泛的应用。</p><h3 id="1-2-现代前端的工作"><a href="#1-2-现代前端的工作" class="headerlink" title="1.2 现代前端的工作"></a>1.2 现代前端的工作</h3><p>现代前端除了解决人机交互这个主要问题外,还拓展出了很多用户体验和工程问题</p><p>用户体验:</p><ul><li><strong>性能优化</strong>: 更加有效的提升用户界面的加载效率</li><li><strong>无障碍化</strong>: 如何保证在不同设备上的兼容性 </li><li><strong>交互设计</strong>: 如何改善在移动设备的交互方式</li><li><strong>个性化需求</strong>: 如何满足个性化需求</li></ul><p>工程配置:</p><ul><li><strong>研发质量</strong>: 如何大幅度提高开发效率和质量</li><li><strong>安全措施</strong>: 如何保证前端安全</li><li><strong>监控和数据</strong>: 如何利用实时监控了解应用健康度</li><li><strong>部署运维</strong>: 如何利用云基础平台进行部署和运维</li></ul><h3 id="1-3-现代前端与过去的区别"><a href="#1-3-现代前端与过去的区别" class="headerlink" title="1.3 现代前端与过去的区别"></a>1.3 现代前端与过去的区别</h3><p>过去的前端主要依赖于HTML、CSS和JavaScript,等技术完成界面开发，对接后端接口即可</p><p>现代前端的能力边界已经拓展了许多，还需要照顾到体验,效能,工程化,数据运营,部署运维,终端安全,多端适配等,这些都是为了更好的服务与人机交互</p><p>举个栗子!现代前端的界面渲染方式已经从客户端渲染(CSR)过渡到部分服务端渲染(SSR),而流式渲染(Streaming)我认为是未来的趋势,流式渲染与服务器渲染的最大区别简单来说就是流式渲染的速度比服务器渲染快</p><p>现代前端很多时候都不全是在做前端的事,前端与服务端的界限已经越来越模糊,当然前端借助服务端所做的一切都是为了服务于用户的体验</p><h2 id="2-什么是DNS"><a href="#2-什么是DNS" class="headerlink" title="2.什么是DNS"></a>2.什么是DNS</h2><p>DNS(Domain Name System)是互联网的基础,它将域名和IP地址相互映射,使得用户可以通过域名访问网站,而不是IP地址,现代DNS服务器除了基本的域名解析功能外，还会提供安全插件(DNSSEC),DNS分析,边缘网络加速解析,DDos防护等功能,这些功能都是为了更快,更安全的为用户提供服务</p><h3 id="2-1-DNS的工作原理"><a href="#2-1-DNS的工作原理" class="headerlink" title="2.1 DNS的工作原理"></a>2.1 DNS的工作原理</h3><p>当用户在浏览器中输入一个域名时,浏览器会首先检查本地的DNS缓存,如果缓存中有对应的IP地址,则直接返回,否则会向本地DNS服务器,最后得到的是IP地址,当然这些服务器大概率不是最终的应用服务器，而是具有反向代理的负载均衡(LB)服务器或WEB应用防火墙(WAW)等,真正的应用服务器IP地址不会暴露在公网环境</p><h3 id="2-2-内容分发系统-CDN-与DNS的关系"><a href="#2-2-内容分发系统-CDN-与DNS的关系" class="headerlink" title="2.2 内容分发系统(CDN)与DNS的关系"></a>2.2 内容分发系统(CDN)与DNS的关系</h3><p>在不同地区的用户在访问前端静态资源时会从不同的cdn节点下载数据,这归功于DNS系统的CNAME记录,DNS服务器会根据用户所在地区的不同,将用户引导到最近的cdn节点也就是CNAME域名,从而提高用户的访问速度</p><p>举个栗子,假如我们的图片资源托管在img.alicdn.com上,通过nslookup工具以此查询当前域名的CNAME和A记录,最终我们会得到CDN服务器的IP地址,实际的地理位置会是在离你最近的CDN节点上</p><p>如栗子所说DNS解析不是一轮完成,会进行多次查询,所以会非常慢,所以不管是DNS云服务器还是互联网上的基础设施,都会想尽办法加速DNS解析的速度如使用高性能的DNS服务器,DNS缓存，增加DNS记录的缓存时间(TTL)等方式,作为前端我们可是使用浏览器提供的DNS预取功能<link rel='dns-prefetch' href='//cdn.example.com'/>来指定需要提前解析的域名,也可以根据DNS的缓存原理通过本地调试的方式设置本地host来解决cookies的跨域问题</p><h2 id="3-什么是HTTP协议"><a href="#3-什么是HTTP协议" class="headerlink" title="3.什么是HTTP协议"></a>3.什么是HTTP协议</h2><p>HTTP协议是连接世界的桥梁,是人们打开互联网的y钥匙,它对于前端的重要性是毫无疑问的,虽然HTTP叫传输协议,但它实际上是工作在TCP/IP协议栈的应用层,底层的数据传输由TCP或UDP负责</p><h3 id="3-1-HTTP的版本"><a href="#3-1-HTTP的版本" class="headerlink" title="3.1 HTTP的版本"></a>3.1 HTTP的版本</h3><ul><li><strong>HTTP/1.1</strong>: 目前还是广泛的版本,它支持持久连接,支持管线化,支持请求和响应的压缩,支持缓存等</li><li><strong>HTTP/2</strong>:引入了多路复用,二进制帧层,头部压缩等特性,提高了不少传输性能</li><li><strong>HTTP/3</strong>:基于QUIC协议使用UDP作为传输层,进一步降低了链接延迟和提高了不少传输性能</li></ul><p>HTTPS是HTTP的安全版本,它使用了SSL/TLS协议来加密数据传输,确保数据的安全性,HTTPS的加密方式有对称加密和非对称加密两种,对称加密是指加密和解密使用同一个密钥,而非对称加密是指加密和解密使用不同的密钥,HTTPS的加密方式是先使用非对称加密来交换密钥,然后使用对称加密来加密数据,这样可以保证数据的安全性(HTTP/3 强制要求需要)</p><h3 id="3-2-HTTP的工作原理"><a href="#3-2-HTTP的工作原理" class="headerlink" title="3.2 HTTP的工作原理"></a>3.2 HTTP的工作原理</h3><p>HTTP协议是基于请求和响应的,客户端向服务器发送请求,服务器处理请求并返回响应,HTTP协议是无状态的,即每次请求都是独立的,服务器不会记录客户端的状态,HTTP协议是基于TCP/IP协议栈的应用层协议,底层的数据传输由TCP或UDP负责</p><p>举个栗子,我的图片放在服务器上,我如果要得到这张图片我可以通过向服务器发送我想要图片的这个请求，服务器收到后会给我反馈也就是响应常见的响应是JSON格式的其中注意code返回的值2开头标识成功,4开头标识失败,5开头标识服务器错误,常见的响应状态码有200,301,302,404,500等</p><h3 id="3-3-异步请求"><a href="#3-3-异步请求" class="headerlink" title="3.3 异步请求"></a>3.3 异步请求</h3><p>前端和服务端的异步请求求通常也是通过HTTP协议完成,最早是通过XMLHttpRequest(XHR)完成的,但是随着ES6的出现,前端也可以使用Fetch API来完成异步请求,异步请求的好处是可以提高用户体验,减少页面的加载时间,但是也会带来一些问题,如请求的顺序问题,请求的并发数问题,请求的缓存问题等,这些问题都需要我们在开发中进行考虑</p><h3 id="3-4-调试工具"><a href="#3-4-调试工具" class="headerlink" title="3.4 调试工具"></a>3.4 调试工具</h3><p>浏览器开发者工具,在Chrome浏览器中可以使用F12打开开发者工具,在开发者工具中通过Network选项卡查看网络请求的请求和响应信息,如想快速看看可以通过cURL等命令行工具完成,在对api测试时可以使用Postman等自动化工具来批量完成,如需要调试移动设备的HTTPS则需要安装信任证书以及通过网络代理工具来实现,如对于远程以及生产环境则需要使用抓包工具和分析服务器日志来完成</p><h3 id="3-5-HTTP在大型客户端应用中的变体"><a href="#3-5-HTTP在大型客户端应用中的变体" class="headerlink" title="3.5 HTTP在大型客户端应用中的变体"></a>3.5 HTTP在大型客户端应用中的变体</h3><p>为了更高效和安全的传输数据,同时兼容HTTP协议,会有一些变化,不是所有的客户端环境都支持先进的HTTP/2或HTTP/3原始HTTP协议在更复杂的高并发场景下会不够高效或稳定,大型技术基建通常会设计一层无线网关(Gateway)并对HTTP协议进行定制添加登录验证,请求跟踪,监控,限流等功能,而前端代码通过远程过程调用(RPC)的方式,而不是使用原始的HTTP,定制化的HTTP协议可以带来更加强大的功能</p></blockquote><!-- 举个栗子,bilibili前端发起一个grpc请求刀gateway网关,同时发送多个自定义请求头 -->]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;h1 id=&quot;关于前端的知识一&quot;&gt;&lt;a href=&quot;#关于前端的知识一&quot; class=&quot;headerlink&quot; title=&quot;关于前端的知识一&quot;&gt;&lt;/a&gt;关于前端的知识一&lt;/h1&gt;&lt;p&gt;本文章主要讲解什么是前端以及了解什么是DNS,http&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于使用JMeter进行并发量测试</title>
    <link href="https://qiride.github.io/post/a1286495.html"/>
    <id>https://qiride.github.io/post/a1286495.html</id>
    <published>2025-02-12T05:06:46.000Z</published>
    <updated>2025-02-13T06:39:11.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于使用JMeter进行并发量测试"><a href="#关于使用JMeter进行并发量测试" class="headerlink" title="关于使用JMeter进行并发量测试"></a>关于使用JMeter进行并发量测试</h1><blockquote><p>在当今的互联网时代，网站的并发量测试是确保网站稳定性和性能的重要手段之一。对于使用Vue.js构建的前端网站，使用JMeter进行并发量测试可以帮助我们了解网站在高并发情况下的表现。本文将介绍如何使用JMeter对Vue网站进行并发量测试。</p><h2 id="1-JMeter什么东东"><a href="#1-JMeter什么东东" class="headerlink" title="1. JMeter什么东东"></a>1. JMeter什么东东</h2><p>Apache JMeter是一个开源的性能测试工具，主要用于对Web应用程序进行负载测试和性能测试。它支持多种协议，如HTTP、HTTPS、FTP、SOAP、REST等，并且可以通过插件扩展功能。</p><h2 id="2-前提条件"><a href="#2-前提条件" class="headerlink" title="2. 前提条件"></a>2. 前提条件</h2><p>在开始测试之前，我们需要准备以下内容：</p><ul><li><strong>JMeter安装</strong>：确保已经安装并配置好JMeter。可以从<a href="https://jmeter.apache.org/download_jmeter.cgi">Apache JMeter官网</a>下载最新版本。</li><li><strong>测试计划</strong>：明确测试的目标，例如测试网站的登录接口、数据加载接口等。<h2 id="3-创建JMeter测试计划"><a href="#3-创建JMeter测试计划" class="headerlink" title="3. 创建JMeter测试计划"></a>3. 创建JMeter测试计划</h2></li></ul><h3 id="3-1-添加线程组"><a href="#3-1-添加线程组" class="headerlink" title="3.1 添加线程组"></a>3.1 添加线程组</h3><ol><li>打开JMeter，右键点击“Test Plan”，选择“Add” -&gt; “Threads (Users)” -&gt; “Thread Group”。</li><li>在“Thread Group”中设置线程数（即并发用户数）、Ramp-Up时间（用户启动时间）和循环次数。</li></ol><h3 id="3-2-添加HTTP请求"><a href="#3-2-添加HTTP请求" class="headerlink" title="3.2 添加HTTP请求"></a>3.2 添加HTTP请求</h3><ol><li>右键点击“Thread Group”，选择“Add” -&gt; “Sampler” -&gt; “HTTP Request”。</li><li>在“HTTP Request”中设置服务器名称或IP（即你的Vue网站地址）、端口号、请求方法（GET/POST等）以及路径。</li><li>如果需要传递参数，可以在“Parameters”或“Body Data”中设置。</li></ol><h3 id="3-3-添加监听器"><a href="#3-3-添加监听器" class="headerlink" title="3.3 添加监听器"></a>3.3 添加监听器</h3><ol><li>右键点击“Thread Group”，选择“Add” -&gt; “Listener” -&gt; “View Results Tree”。</li><li>添加其他监听器，如“Summary Report”或“Graph Results”，以便查看测试结果。</li></ol><h3 id="4-运行测试"><a href="#4-运行测试" class="headerlink" title="4. 运行测试"></a>4. 运行测试</h3><ol><li>点击JMeter工具栏上的“Start”按钮，开始运行测试。</li><li>在测试过程中，可以通过监听器实时查看测试结果。</li></ol><h3 id="5-分析测试结果"><a href="#5-分析测试结果" class="headerlink" title="5. 分析测试结果"></a>5. 分析测试结果</h3><p>测试完成后，可以通过以下方式分析结果：</p><ul><li><strong>View Results Tree</strong>：查看每个请求的详细结果，包括请求和响应数据。</li><li><strong>Summary Report</strong>：查看测试的总体结果，包括平均响应时间、吞吐量、错误率等。</li><li><strong>Graph Results</strong>：以图表形式展示响应时间、吞吐量等指标的变化趋势。</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于使用JMeter进行并发量测试&quot;&gt;&lt;a href=&quot;#关于使用JMeter进行并发量测试&quot; class=&quot;headerlink&quot; title=&quot;关于使用JMeter进行并发量测试&quot;&gt;&lt;/a&gt;关于使用JMeter进行并发量测试&lt;/h1&gt;&lt;blockquote&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>建站啦！！！</title>
    <link href="https://qiride.github.io/post/21ba1eea.html"/>
    <id>https://qiride.github.io/post/21ba1eea.html</id>
    <published>2025-02-11T05:04:23.000Z</published>
    <updated>2025-02-13T06:46:02.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="建站啦！！！"><a href="#建站啦！！！" class="headerlink" title="建站啦！！！"></a>建站啦！！！</h1><blockquote><p>2025-02-11 13:04:23<br>今天是我建站的第一天，我要做一个博客，记录我的学习过程，也记录我的生活。</p><h2 id="我要做什么？"><a href="#我要做什么？" class="headerlink" title="我要做什么？"></a>我要做什么？</h2><ul><li>记录我的学习过程</li><li>记录我的生活</li><li>记录我的心情</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;建站啦！！！&quot;&gt;&lt;a href=&quot;#建站啦！！！&quot; class=&quot;headerlink&quot; title=&quot;建站啦！！！&quot;&gt;&lt;/a&gt;建站啦！！！&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;2025-02-11 13:04:23&lt;br&gt;今天是我建站的第一天，我要做一个博客</summary>
      
    
    
    
    
  </entry>
  
</feed>
